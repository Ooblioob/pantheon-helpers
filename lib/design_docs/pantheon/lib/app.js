// Generated by CoffeeScript 1.9.1
(function() {
  var _, dd, emit, sendNakedList;

  _ = require('underscore');

  sendNakedList = function(getRow, start, send, rowTransform) {

    /*
    lazily send a JSON serialized list of rows,
    each having been transformed by rowTransform.
    If rowTransform throws the string `"skip"`,
    the row will be skipped.
    
    coppied from pantheon-helpers-design-docs.helpers
    b/c npm does not preserve symlinks
     */
    var e, first, row, transformedRow;
    start({
      headers: {
        'Content-Type': 'application/json'
      }
    });
    first = true;
    send('[');
    while ((row = getRow())) {
      try {
        transformedRow = rowTransform(row);
      } catch (_error) {
        e = _error;
        if (e === 'skip') {
          continue;
        } else {
          throw e;
        }
      }
      if (first) {
        first = false;
      } else {
        send(',');
      }
      send(JSON.stringify(transformedRow));
    }
    return send(']');
  };

  dd = {
    views: {
      failures_by_retry_date: {
        map: function(doc) {
          var entry, i, len, nextAttemptTime, now, ref, ref1, ref2;
          now = +new Date();
          nextAttemptTime = 1e+100;
          ref = doc.audit || [];
          for (i = 0, len = ref.length; i < len; i++) {
            entry = ref[i];
            if (((ref1 = entry.attempts) != null ? ref1[0] : void 0) < nextAttemptTime) {
              nextAttemptTime = (ref2 = entry.attempts) != null ? ref2[0] : void 0;
            }
          }
          if (nextAttemptTime < 1e+100) {
            return emit(nextAttemptTime);
          }
        }
      },
      audit_by_timestamp: {
        map: function(doc) {
          var entry, i, len, out, ref, results, typ;
          ref = doc.audit;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            entry = ref[i];
            typ = doc._id.indexOf('team_') === 0 ? 'team' : 'user';
            out = {
              _id: doc._id,
              name: doc.name,
              entry: entry,
              type: typ
            };
            results.push(emit(entry.dt, out));
          }
          return results;
        }
      }
    },
    lists: {
      get_values: function(header, req) {
        return sendNakedList(getRow, start, send, function(row) {
          return row.value;
        });
      }
    },
    rewrites: [
      {
        from: "/audit",
        to: "/_list/get_values/audit_by_timestamp",
        query: {}
      }
    ],
    shows: {},
    updates: {}
  };

  if (typeof emit === 'undefined') {
    dd.emitted = [];
    emit = function(k, v) {
      return dd.emitted.push([k, v]);
    };
  }

  module.exports = dd;

}).call(this);
