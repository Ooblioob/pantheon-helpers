// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var Promise, clone, follow, utils, x, _;

  _ = require('underscore');

  follow = require('follow');

  utils = require('./utils');

  Promise = require('promise');

  x = {};

  clone = function(obj) {
    var newClone;
    newClone = JSON.parse(JSON.stringify(obj));
    return newClone;
  };

  x.get_handlers = function(handlers, entry, doc_type) {

    /*
    return a hash of {null: handler}, where handler is the handler
    for the entry/doc type combo.
    
    you can subclass this function to return an arbitrary 
    number of key/handler names. (see, e.g., get_resource_handlers)
     */
    var handler, _ref;
    handler = (_ref = handlers[doc_type]) != null ? _ref[entry.a] : void 0;
    if (handler) {
      return {
        "null": handler
      };
    } else {
      return {};
    }
  };

  x.get_plugin_handlers = function(handlers, entry, doc_type) {

    /*
    return a hash of {resource: handler} for each resource that
    has specified a handler for this entry's action.
     */
    var entry_plugin, filtered_handlers, handler, plugin, plugin_handlers, _ref, _ref1, _ref2, _ref3, _ref4;
    filtered_handlers = {};
    for (plugin in handlers) {
      plugin_handlers = handlers[plugin];
      handler = (_ref = plugin_handlers[doc_type]) != null ? _ref[entry.a] : void 0;
      if (!handler) {
        entry_plugin = entry.plugin || entry.resource;
        if (entry_plugin === plugin) {
          handler = (_ref1 = plugin_handlers[doc_type]) != null ? (_ref2 = _ref1.self) != null ? _ref2[entry.a] : void 0 : void 0;
        } else {
          handler = (_ref3 = plugin_handlers[doc_type]) != null ? (_ref4 = _ref3.other) != null ? _ref4[entry.a] : void 0 : void 0;
        }
      }
      if (handler) {
        filtered_handlers[plugin] = handler;
      }
    }
    return filtered_handlers;
  };

  x.get_unsynced_audit_entries = function(doc) {
    return _.filter(doc.audit, function(entry) {
      return !entry.synced;
    });
  };

  x.update_document_with_worker_result = function(doc) {
    return function(result) {
      var data_path, existing_data, new_data, _ref, _ref1, _ref2, _ref3;
      data_path = ((_ref = result.value) != null ? _ref.path : void 0) || ((_ref1 = result.error) != null ? _ref1.path : void 0);
      new_data = ((_ref2 = result.value) != null ? _ref2.data : void 0) || ((_ref3 = result.error) != null ? _ref3.data : void 0);
      if (new_data && data_path) {
        existing_data = utils.mk_objs(doc, data_path, {});
        return _.extend(existing_data, new_data);
      }
    };
  };

  x.update_audit_entry = function(doc) {
    return function(entry_results, entry_id) {
      var entry, synced;
      entry = _.findWhere(doc.audit, {
        id: entry_id
      });
      synced = _.all(entry_results, function(result) {
        return result.state === 'resolved';
      });
      entry.synced = entry.synced || synced;
      return _.each(entry_results, x.update_document_with_worker_result(doc));
    };
  };

  x.update_audit_entries = function(db, doc_id, results) {
    var get_doc, insert_doc;
    get_doc = Promise.denodeify(db.get).bind(db);
    insert_doc = Promise.denodeify(db.insert).bind(db);
    return get_doc(doc_id).then(function(doc) {
      var old_doc;
      old_doc = clone(doc);
      _.each(results, x.update_audit_entry(doc));
      if (_.isEqual(old_doc, doc)) {
        return Promise.resolve();
      } else {
        return insert_doc(doc)["catch"](function(err) {
          if (err.status_code === 409) {
            return x.update_audit_entries(db, doc_id, doc_type, results);
          } else {
            return Promise.reject(err);
          }
        });
      }
    });
  };

  x.on_change = function(db, handlers, get_doc_type, get_handlers) {
    return function(change) {
      var doc, doc_type, entry_promises, unsynced_audit_entries;
      doc = change.doc;
      doc_type = get_doc_type(doc);
      unsynced_audit_entries = x.get_unsynced_audit_entries(doc);
      entry_promises = {};
      _.each(unsynced_audit_entries, function(entry) {
        var entry_handlers, handler_promises;
        entry_handlers = get_handlers(handlers, entry, doc_type);
        handler_promises = {};
        _.each(entry_handlers, function(handler, rsrc) {
          return handler_promises[rsrc] = handler(clone(entry), clone(doc));
        });
        return entry_promises[entry.id] = Promise.hashResolveAll(handler_promises);
      });
      return Promise.hashAll(entry_promises).then(function(results) {
        x.update_audit_entries(db, doc._id, results);
        if (_.find(results, function(result) {
          return _.findWhere(result, {
            state: 'rejected'
          });
        })) {
          return console.log('ERR', change.doc, unsynced_audit_entries, results);
        }
      })["catch"](function(err) {
        return console.log('ERR', err);
      });
    };
  };

  x.start_worker = function(db, handlers, get_doc_type, get_handlers) {
    var feed, opts;
    if (get_handlers == null) {
      get_handlers = x.get_handlers;
    }

    /*
    start a worker that watches a db for changes and calls the appropriate handlers.
    db: the nano database to watch
    handlers: a hash of handlers. Each handler should handle a different action.
    get_handler_data_path: a function that return a path array into the document where data returned by the handler should be stored.
    get_doc_type: a function that returns the document type. this can be used to look up the appropriate handler.
     */
    opts = {
      db: db.config.url + '/' + db.config.db,
      include_docs: true
    };
    feed = new follow.Feed(opts);
    feed.filter = function(doc, req) {
      if (doc._deleted) {
        return false;
      } else {
        return true;
      }
    };
    feed.on('change', x.on_change(db, handlers, get_doc_type, get_handlers));
    feed.on('error', function(err) {
      return console.log(err);
    });
    feed.follow();
    return feed;
  };

  module.exports = x;

}).call(this);
