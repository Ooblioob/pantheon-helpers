// Generated by CoffeeScript 1.9.1
(function() {
  var Promise, _, a, deepSimpleClone, uuid, validate;

  _ = require('underscore');

  uuid = require('node-uuid');

  Promise = require('./promise');

  a = {};

  validate = require('./validateDocUpdate');

  deepSimpleClone = function(obj) {
    return JSON.parse(JSON.stringify(obj));
  };

  a.getUser = function(client, systemUserName, userName) {

    /* returns promise */
    var systemUser, userDb;
    if (_.isObject(userName)) {
      return Promise.resolve(userName);
    }
    if (userName === systemUserName) {
      systemUser = {
        name: systemUserName,
        roles: []
      };
      return Promise.resolve(systemUser);
    } else {
      userDb = client.use('_users');
      return userDb.get('org.couchdb.user:' + userName, 'promise');
    }
  };

  a.getDoc = function(client, dbName, docId) {

    /* returns promise */
    if (_.isObject(docId)) {
      return Promise.resolve(docId);
    } else if (docId) {
      return client.use(dbName).get(docId, 'promise');
    } else {
      return client.getUuid().then(function(uuid) {
        return Promise.resolve({
          _id: uuid,
          audit: []
        });
      });
    }
  };

  a.getActionHandler = function(actionHandlers, getDocType) {
    return function(doc, action) {
      var actionHandler, actionName, docType, errorMsg, isNewDoc, ref;
      actionName = action.a;
      isNewDoc = !doc._rev;
      docType = isNewDoc ? 'create' : getDocType(doc);
      actionHandler = (ref = actionHandlers[docType]) != null ? ref[actionName] : void 0;
      if (!actionHandler) {
        errorMsg = 'invalid action "' + actionName + '" for doc type "' + docType + '".';
        throw {
          code: 403,
          body: {
            "status": "error",
            "msg": errorMsg
          }
        };
      }
      return actionHandler;
    };
  };

  a.runHandler = function(actionHandler, doc, action, actor) {
    var e;
    try {
      return actionHandler(doc, action, actor);
    } catch (_error) {
      e = _error;
      throw {
        code: 500,
        body: {
          "status": "error",
          "msg": e
        }
      };
    }
  };

  a.doAction = function(dbName, couchUtils, actionHandlers, validationFns, getDocType, prepDoc, shouldSkipValidationForUser) {
    var doAction, getActionHandler, validateDocUpdate;
    validateDocUpdate = validate.validateDocUpdate(validationFns, getDocType, shouldSkipValidationForUser);
    getActionHandler = a.getActionHandler(actionHandlers, getDocType);
    doAction = function(dbName, actorName, docId, action) {

      /*
      return a doAction method to perform actions of documents in databases
      returned doAction function returns a promise.
      args:
        client: configuration object
        dbName: name of the db in which to perform action
        actionHandlers: 
        getDocType:
        validateDocUpdate:
        prepDoc:
      returned doAction method args:
        dbName: (only if dbName above is undefined)
        actorName: name (or user object) of the user performing the action
        docId: docId (or document object) of the document on which to perform action
        action: action object describing the action
       */
      var actorPromise, client, docPromise, oldAction, systemUserName;
      oldAction = deepSimpleClone(action);
      _.defaults(action, {
        id: uuid.v4()
      });
      client = couchUtils.nano_user(actorName.name || actorName);
      systemUserName = couchUtils.conf.COUCHDB.SYSTEM_USER;
      actorPromise = a.getUser(client, systemUserName, actorName);
      docPromise = a.getDoc(client, dbName, docId);
      return Promise.all([actorPromise, docPromise]).then(function(arg) {
        var actionHandler, actor, doc, oldDoc;
        actor = arg[0], doc = arg[1];
        oldDoc = deepSimpleClone(doc);
        actionHandler = getActionHandler(doc, action);
        a.runHandler(actionHandler, doc, action, actor);
        if (_.isEqual(oldDoc, doc)) {
          return Promise.resolve([actor, doc]);
        }
        validateDocUpdate(doc, oldDoc, actor);
        _.extend(action, {
          u: actor.name,
          dt: +new Date()
        });
        doc.audit.push(action);
        return client.use(dbName).insert(doc, 'promise')["catch"](function(err) {
          var originalId;
          if (err.statusCode === 409) {
            originalId = (docId != null ? docId._id : void 0) || docId;
            return doAction(dbName, actorName, originalId, oldAction);
          } else {
            return Promise.reject(err);
          }
        }).then(function() {
          return Promise.resolve([actor, doc]);
        });
      }).then(function(arg) {
        var actor, doc, outDoc;
        actor = arg[0], doc = arg[1];
        outDoc = prepDoc ? prepDoc(doc, actor) : doc;
        return Promise.resolve(outDoc);
      });
    };
    if (dbName != null) {
      return function(actorName, docId, action) {
        return doAction(dbName, actorName, docId, action);
      };
    } else {
      return doAction;
    }
  };

  module.exports = a;

}).call(this);
